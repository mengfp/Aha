/*
** Copyright 2025 Meng, Fanping. All rights reserved.
*/

Model<T>::Model(int rank, int dim) {
  p = new mix<T>(rank, dim);
}

Model<T>::~Model() {
  delete (mix<T>*)p;
}

bool Model<T>::Initialized() const {
  return ((mix<T>*)p)->Initialized();
}

int Model<T>::Rank() const {
  return ((mix<T>*)p)->Rank();
}

int Model<T>::Dim() const {
  return ((mix<T>*)p)->Dim();
}

double Model<T>::Predict(const Vector<T>& x, Vector<T>& y) const {
  return ((mix<T>*)p)->Predict(x, y);
}

double Model<T>::Predict(const std::vector<T>& x,
                      std::vector<T>& y) const {
  Eigen::Map<const Vector<T>> _x(x.data(), x.size());
  Vector<T> _y;
  auto r = ((mix<T>*)p)->Predict(_x, _y);
  y.assign(_y.begin(), _y.end());
  return r;
}

void Model<T>::Sort() {
  return ((mix<T>*)p)->Sort();
}

std::string Model<T>::Export() const {
  return ((mix<T>*)p)->Export();
}

bool Model<T>::Import(const std::string& model) {
  return ((mix<T>*)p)->Import(model);
}

Trainer<T>::Trainer(Model<T>& m) {
  p = new trainer<T>(*(mix<T>*)*(void**)&m);
}

Trainer<T>::~Trainer() {
  delete (trainer<T>*)p;
}

int Trainer<T>::Rank() const {
  return ((trainer<T>*)p)->Rank();
}

int Trainer<T>::Dim() const {
  return ((trainer<T>*)p)->Dim();
}

void Trainer<T>::Train(const Vector<T>& sample) {
  ((trainer<T>*)p)->Train(sample);
}

void Trainer<T>::Train(const std::vector<T>& sample) {
  Eigen::Map<const Vector<T>> s(sample.data(), sample.size());
  ((trainer<T>*)p)->Train(s);
}

bool Trainer<T>::Merge(const Trainer& t, double w) {
  return ((trainer<T>*)p)->Merge(*(const trainer<T>*)*(void**)&t, w);
}

std::string Trainer<T>::Spit() {
  return ((trainer<T>*)p)->Spit();
}

bool Trainer<T>::Swallow(const std::string& t, double w) {
  return ((trainer<T>*)p)->Swallow(t, w);
}

double Trainer<T>::Update(double noise_floor) {
  return ((trainer<T>*)p)->Update(noise_floor);
}

void Trainer<T>::Reset() {
  ((trainer<T>*)p)->Reset();
}